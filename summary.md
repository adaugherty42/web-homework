# Backend Objective Summary

I'm applying for a mid-level backend position, but I took a swing at all the objectives anyway.

## Allow the mutations to handle a decimal amount for transactions (the database stores it as cents)
I started with this one. Obviously floating point numbers are unsuitable for financial purposes, so I looked around for an Elixir equivalent to the java BigDecimal class. I ended up finding the Decimal and Money libraries, but Decimal was much simpler so I went with that. The biggest issue was figuring out where exactly in the pipeline to put the conversion, and I settled on the layer that makes direct calls to the repository (e.g. transactions.ex). I think this was a good decision, because any consumer of the methods in that layer should expect to receive transaction amounts in decimal form, not an integer number of cents.

## Write a new schema, queries, and mutations to add companies to the app
Most of this was straightforward, because the app already included a complete solution for 3 other domain objects. It was just a matter of studying the codebase a bit to find all the necessary places to add logic for companies. I think my company-to-transaction relationship was the weakest part of the whole project. My mind naturally gravitates to a normalized database, so I made the "available credit" field transient and set up logic to calculate it during reads. Ultimately I think this is probably a bad idea, because the read:write ratio will likely be skewed heavily in favor of reads. This means that we'll be doing a ton of scans of the transactions table, and even though it'll be indexed, it's still less efficient than just taking the denormalized approach and keeping "available credit" as an actual DB column that gets updated while posting a transaction.

On the bright side, these first two objectives served as a nice intro to the Elixir piping mechanism, which is very cool and reminds me of using the Linux terminal. Once I got the hang of it, it was straightforward to do things like a currency conversion or available credit calculation.

## Seed the database.
Not much to say here, this is just a matter of learning the proper syntax for Ecto. The trick here is matching the objects with no dependencies to variables, so that you can build subsequent objects that reference their primary key (since they're autogenerated UUIDs). Naturally I went with Futurama-themed objects.

## Write tests for the resolvers & mutations.
I wrote the standard suite of tests for the new company domain object, and additionally added some extra tests to verify the companies-to-transactions relationship. Specifically, we have to check for situations where a transaction is created or updated. If the transaction amount exceeds a company's available balance, the operation must be canceled and an error thrown. It's also possible for the transaction to be switched to a different company, so I tested that as well. For the sake of completeness, it would have been better to also add tests to verify that filtering works.

## Write filtering options for transactions, users, and/or merchants.
My favorite objective. I started with the obvious approach of adding a where clause to the query, and giving the field a default value so that it'll work even if the user doesn't supply the filter. This fell apart when I had to add min/max values, so I did some Ecto research. It turns out Ecto queries are composable, which is an amazing feature that really lends itself to beautiful functional code. I found a particularly elegant solution for basic filtering which I based mine off of, and cited it somewhere in a comment. The idea is to start with a basic query that translates to "SELECT * FROM TABLENAME", and then leverage query composition to run a reduce function over all the supplied filter parameters. Since my nerdy computer science brain enjoyed this, I added filtering to all 4 domain objects.

## Add a pagination layer to the queries
I have mixed feelings on this one. On the one hand, it's pretty easy to use Ecto composition to build a utility class that slaps "LIMIT/OFFSET" clauses on a query, but I ended up having to create new graphql objects to handle it. I'm not a huge fan of having "transactions" and "transactionsPaged" and I'd prefer to find a way to make it all work under one object. Did I mention how nice Ecto query composition is? Combining pagination and filtering took precisely zero extra work thanks to this feature.

## Time
I was chipping away at this on weekdays after work, so the schedule was a little erratic.  My best estimate would be 16-18 hours, because I put at least 4 hours in on each of the first 3 days, and then scaled it back a bit after that. The objectives themselves were fairly simple, but Elixir embarrassed me more than a few times over the course of this project.

## Other
The transaction changeset was omitting the "credit" field, so all transactions were falling back to the default value of "false."

I didn't spot an overt security issue while working through this, other than the fact that I didn't really see any kind of access token validation for the graphql calls (could have missed it somewhere in the phoenix plumbing code).

Thank you for looking!